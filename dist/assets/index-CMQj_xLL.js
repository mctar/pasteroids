var W=Object.defineProperty;var I=(c,e,o)=>e in c?W(c,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):c[e]=o;var l=(c,e,o)=>I(c,typeof e!="symbol"?e+"":e,o);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function o(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=o(i);fetch(i.href,n)}})();const t={core:{zero:0,one:1,two:2,half:.5,negativeOne:-1},dom:{canvasId:"game"},math:{tau:Math.PI*2,epsilon:1e-6},rng:{seed:1337,multiplier:48271,increment:0,modulus:2147483647},timing:{fixedFps:60,msPerSecond:1e3,maxFrameMs:1e3/10,maxSubSteps:5},input:{startKey:"Space",fireKey:"Space",pauseKey:"KeyP",leftKey:"KeyA",rightKey:"KeyD",thrustKey:"KeyW",weaponPrevKey:"KeyQ",weaponNextKey:"KeyE",trailToggleKey:"KeyT",debugToggleKey:"Backquote",hitboxToggleKey:"KeyH",turnLeft:-1,turnRight:1,turnNone:0},game:{states:{attract:"attract",playing:"playing",gameOver:"gameOver"},startingScore:0,startingWave:1},wave:{baseNoodles:1,increment:1,spawnAttempts:12,safeRadius:120},world:{maxNoodles:50,maxProjectiles:200,maxParticles:120,entityStartId:1,centerDivisor:2,wrapMargin:0},canvas:{minDpr:1,maxDpr:2,background:"#0f1116",textColor:"#f4f1de",accentColor:"#e07a5f"},render:{lineWidth:2,fontFamily:"monospace",hintFontSize:26,hudFontSize:16,hudLineHeight:20,shipScale:1,noodleScale:1},debug:{enabled:!1,hitboxes:!1,projectileTrails:!1,fpsLabel:"FPS",accumulatorLabel:"acc",stepLabel:"step",subStepsLabel:"sub",shipLabel:"ship",noodleLabel:"noodle",projectileLabel:"projectile",particleLabel:"particle",frameLabel:"frame",activeLabel:"Active",hitboxLabel:"Hitboxes",msSuffix:"ms",onLabel:"On",offLabel:"Off",overlayFontSize:14,overlayLineHeight:18,overlayPadding:12,precision:2,fpsSmoothing:.9,hitboxColor:"#f2cc8f",hitboxLineWidth:1,trailColor:"#f2cc8f",trailLineWidth:1,projectileTrailLength:12},fuse:{scale:.6,color:"#f2cc8f",lineWidth:1},explosion:{color:"#f2cc8f",lineWidth:2},ship:{radius:14,turnSpeed:3.4,thrustAccel:180,maxSpeed:260,damping:.99,noseScale:1.4,wingScale:.7,tailScale:.9,flameScale:.7,color:"#f4f1de"},noodle:{longAxis:60,shortAxis:40,driftSpeed:40,angularVelocity:.6,damping:.995,color:"#81b29a",splitThreshold:50,splitScale:.6,splitCount:2,splitImpulseMin:20,splitImpulseMax:60,tiers:[{minLongAxis:60,hp:3,score:100},{minLongAxis:40,hp:2,score:50},{minLongAxis:0,hp:1,score:25}]},projectile:{radius:2,color:"#f2cc8f",lifetimeSeconds:1.2,damage:1,accel:{x:0,y:0}},weapon:{defaultId:"straightShot",straightShot:{id:"straightShot",name:"Straight Shot",cooldownSeconds:.2,projectileSpeed:520,spawnOffsetScale:1},parabolic:{id:"parabolicShot",name:"Parabolic Shot",cooldownSeconds:.35,projectileSpeed:480,spawnOffsetScale:1,gravity:260},blast:{id:"blastShot",name:"Blast Shot",cooldownSeconds:.6,projectileSpeed:320,projectileRadius:6,projectileDamage:0,spawnOffsetScale:1,lifetimeSeconds:1.4,explosionRadius:90,explosionDamage:2,explosionImpulse:140,explosionDurationSeconds:.4},rearCannons:{id:"rearCannons",name:"Rear Cannons",cooldownSeconds:.35,projectileSpeed:380,lifetimeSeconds:1,hardpoints:[{x:-18,y:-8},{x:-18,y:8}]}},hud:{startHint:"Press Space to Start",restartHint:"Press Space to restart",pauseHint:"Paused - Press P to resume",scoreLabel:"Score",weaponLabel:"Weapon",waveLabel:"Wave",cooldownLabel:"Cooldown",cooldownReady:"Ready",cooldownUnknown:"--",cooldownPrecision:2,secondsSuffix:"s",statusLabel:"Noodles"}},q=(c,e,o)=>{const s=()=>{const i=Math.min(t.canvas.maxDpr,Math.max(t.canvas.minDpr,window.devicePixelRatio)),n=c.clientWidth,r=c.clientHeight,a=Math.floor(n*i),d=Math.floor(r*i);(c.width!==a||c.height!==d)&&(c.width=a,c.height=d),e.setTransform(i,t.core.zero,t.core.zero,i,t.core.zero,t.core.zero),o(n,r)};return s(),s};class F{constructor(e){l(this,"seed");const o=t.rng.modulus,s=e??this.autoSeed(o);this.seed=this.normalizeSeed(s,o)}next(){const e=t.rng.modulus,o=t.rng.multiplier,s=t.rng.increment;return this.seed=(o*this.seed+s)%e,this.seed}nextFloat(){return this.next()/t.rng.modulus}range(e,o){return e+(o-e)*this.nextFloat()}normalizeSeed(e,o){const s=Math.abs(e)%o;return s===t.core.zero?t.core.one:s}autoSeed(e){return Date.now()%e}}const b=(c,e,o)=>c<e?e:c>o?o:c;class M{constructor(e,o){l(this,"width");l(this,"height");l(this,"score");l(this,"wave");l(this,"debug");l(this,"collisions",[]);l(this,"rng");l(this,"explosions",[]);l(this,"nextEntityId",t.world.entityStartId);l(this,"entities",new Set);l(this,"transforms",new Map);l(this,"rigidBodies",new Map);l(this,"shipControls",new Map);l(this,"weaponStates",new Map);l(this,"noodles",new Map);l(this,"projectiles",new Map);l(this,"lifetimes",new Map);l(this,"expiredProjectiles",new Set);l(this,"pendingImpulses",new Map);l(this,"playerShipId");this.width=e,this.height=o,this.score=t.game.startingScore,this.wave=t.game.startingWave,this.rng=new F(t.rng.seed),this.debug={enabled:t.debug.enabled,showHitboxes:t.debug.hitboxes,showProjectileTrails:t.debug.projectileTrails,fps:t.core.zero,frameMs:t.core.zero,accumulatorMs:t.core.zero,fixedStepMs:t.core.zero,subSteps:t.core.zero};const s=e/t.world.centerDivisor,i=o/t.world.centerDivisor;this.playerShipId=this.createShip(s,i)}setSize(e,o){this.width=e,this.height=o}createEntity(){const e=this.nextEntityId;return this.nextEntityId+=t.core.one,this.entities.add(e),e}destroyEntity(e){this.entities.delete(e),this.transforms.delete(e),this.rigidBodies.delete(e),this.shipControls.delete(e),this.weaponStates.delete(e),this.noodles.delete(e),this.projectiles.delete(e),this.lifetimes.delete(e)}getPlayerShipId(){return this.playerShipId}getEntityCount(){return this.entities.size}getShipCount(){return this.shipControls.size}getNoodleCount(){return this.noodles.size}getProjectileCount(){return this.projectiles.size}getParticleCount(){return this.explosions.length}getTransform(e){return this.transforms.get(e)}getRigidBody(e){return this.rigidBodies.get(e)}getShipControl(e){return this.shipControls.get(e)}getWeaponState(e){return this.weaponStates.get(e)}getNoodle(e){return this.noodles.get(e)}getProjectile(e){return this.projectiles.get(e)}getLifetime(e){return this.lifetimes.get(e)}getShipEntries(){return this.shipControls.entries()}getWeaponStateEntries(){return this.weaponStates.entries()}getNoodleEntries(){return this.noodles.entries()}getProjectileEntries(){return this.projectiles.entries()}getRigidBodyEntries(){return this.rigidBodies.entries()}markProjectileExpired(e){this.expiredProjectiles.add(e)}consumeExpiredProjectiles(){const e=Array.from(this.expiredProjectiles);return this.expiredProjectiles.clear(),e}queueImpulse(e,o){const s=this.pendingImpulses.get(e);if(s){s.x+=o.x,s.y+=o.y;return}this.pendingImpulses.set(e,{x:o.x,y:o.y})}consumeImpulses(){const e=new Map(this.pendingImpulses);return this.pendingImpulses.clear(),e}spawnProjectile(e,o,s,i){if(this.projectiles.size>=t.world.maxProjectiles)return;const n=this.createEntity(),r=s??t.projectile.lifetimeSeconds,a=(i==null?void 0:i.accel)??{x:t.projectile.accel.x,y:t.projectile.accel.y},d=(i==null?void 0:i.radius)??t.projectile.radius,h=(i==null?void 0:i.damage)??t.projectile.damage,p=(i==null?void 0:i.proximityFuseEnabled)??!1;return this.transforms.set(n,{position:{x:e.x,y:e.y},rotation:t.core.zero}),this.rigidBodies.set(n,{velocity:{x:o.x,y:o.y},angularVelocity:t.core.zero}),this.projectiles.set(n,{radius:d,damage:h,accel:{x:a.x,y:a.y},trail:[{x:e.x,y:e.y}],proximityFuseEnabled:p,explosion:i==null?void 0:i.explosion}),this.lifetimes.set(n,{remainingSeconds:r}),n}addExplosion(e){for(;this.explosions.length>=t.world.maxParticles;)this.explosions.shift();this.explosions.push(e)}clearCollisions(){this.collisions.length=t.core.zero}addCollision(e,o){this.collisions.push({a:e,b:o})}toggleDebug(){this.debug.enabled=!this.debug.enabled}toggleHitboxes(){this.debug.showHitboxes=!this.debug.showHitboxes}toggleProjectileTrails(){this.debug.showProjectileTrails=!this.debug.showProjectileTrails}createShip(e,o){const s=this.createEntity();return this.transforms.set(s,{position:{x:e,y:o},rotation:t.core.zero}),this.rigidBodies.set(s,{velocity:{x:t.core.zero,y:t.core.zero},angularVelocity:t.core.zero}),this.shipControls.set(s,{turn:t.input.turnNone,thrusting:!1,radius:t.ship.radius}),this.weaponStates.set(s,{weaponId:t.weapon.defaultId,cooldownRemaining:t.core.zero}),s}spawnNoodle(e,o,s,i,n=t.core.zero,r=t.noodle.angularVelocity){if(this.noodles.size>=t.world.maxNoodles)return;const a=this.createEntity(),d=this.resolveNoodleStats(s);return this.transforms.set(a,{position:{x:e.x,y:e.y},rotation:n}),this.rigidBodies.set(a,{velocity:{x:o.x,y:o.y},angularVelocity:r}),this.noodles.set(a,{longAxis:s,shortAxis:i,hp:d.hp,scoreValue:d.score}),a}spawnWave(e,o){const s=t.world.maxNoodles-this.noodles.size,i=Math.min(e,s);if(i<=t.core.zero)return;const n=this.getTransform(this.playerShipId),r=n?n.position:{x:this.width/t.world.centerDivisor,y:this.height/t.world.centerDivisor};for(let a=t.core.zero;a<i;a+=t.core.one){const d=this.resolveSpawnPosition(r,o),h=this.randomNoodleVelocity(),p=this.rng.range(t.core.zero,t.math.tau),u=this.randomNoodleAngularVelocity();if(!this.spawnNoodle(d,h,t.noodle.longAxis,t.noodle.shortAxis,p,u))return}}resolveSpawnPosition(e,o){const s=o*o;let i={x:e.x,y:e.y};for(let a=t.core.zero;a<t.wave.spawnAttempts;a+=t.core.one){i={x:this.rng.range(t.core.zero,this.width),y:this.rng.range(t.core.zero,this.height)};const d=i.x-e.x,h=i.y-e.y;if(d*d+h*h>=s)return i}const n=this.rng.range(t.core.zero,t.math.tau),r={x:e.x+Math.cos(n)*o,y:e.y+Math.sin(n)*o};return{x:b(r.x,t.core.zero,this.width),y:b(r.y,t.core.zero,this.height)}}randomNoodleVelocity(){const e=this.rng.range(t.core.zero,t.math.tau);return{x:Math.cos(e)*t.noodle.driftSpeed,y:Math.sin(e)*t.noodle.driftSpeed}}randomNoodleAngularVelocity(){const e=this.rng.nextFloat()<t.core.half?t.core.negativeOne:t.core.one;return t.noodle.angularVelocity*e}resolveNoodleStats(e){for(const o of t.noodle.tiers)if(e>=o.minLongAxis)return{hp:o.hp,score:o.score};return{hp:t.core.one,score:t.core.zero}}}const x=(c,e)=>({x:c,y:e}),m=(c,e)=>({x:c.x+e.x,y:c.y+e.y}),w=(c,e)=>({x:c.x-e.x,y:c.y-e.y}),g=(c,e)=>({x:c.x*e,y:c.y*e}),z=(c,e)=>c.x*e.x+c.y*e.y,P=(c,e)=>{const o=Math.cos(e),s=Math.sin(e);return{x:c.x*o-c.y*s,y:c.x*s+c.y*o}},j=(c,e,o,s)=>{const n=Math.max(t.core.zero,o-s)*t.core.half,r=P(x(t.core.one,t.core.zero),e),a=g(r,n);return{start:w(c,a),end:m(c,a),radius:s*t.core.half,axis:r}},L=(c,e,o,s,i,n)=>{const r=j(o,s,i,n),a=R(c,r.start,r.end),d=w(c,a),h=z(d,d),p=e+r.radius,u=p*p;if(h>u)return{hit:!1,normal:null};const f=t.math.epsilon*t.math.epsilon;if(h<=f)return{hit:!0,normal:r.axis};const S=Math.sqrt(h);return{hit:!0,normal:g(d,t.core.one/S)}},R=(c,e,o)=>{const s=w(o,e),i=z(s,s),n=t.math.epsilon*t.math.epsilon;if(i<=n)return x(e.x,e.y);const r=w(c,e),a=z(r,s)/i,d=b(a,t.core.zero,t.core.one);return m(e,g(s,d))},A=(c,e,o)=>{const s=R(c,e,o),i=w(c,s);return z(i,i)};class ${update(e){e.clearCollisions(),this.checkShipNoodles(e);const o=new Set,s=new Set;this.checkProjectileNoodles(e,s,o),this.handleExpiredProjectiles(e,s,o);for(const i of s)e.destroyEntity(i);for(const i of o)e.destroyEntity(i)}checkShipNoodles(e){for(const[o,s]of e.getShipEntries()){const i=e.getTransform(o);if(i)for(const[n,r]of e.getNoodleEntries()){const a=e.getTransform(n);if(!a)continue;L(i.position,s.radius,a.position,a.rotation,r.longAxis,r.shortAxis).hit&&e.addCollision(o,n)}}}checkProjectileNoodles(e,o,s){for(const[i,n]of e.getProjectileEntries()){if(o.has(i))continue;const r=e.getTransform(i);if(r)for(const[a,d]of e.getNoodleEntries()){if(s.has(a))continue;const h=e.getTransform(a);if(!h)continue;const p=this.checkProximityFuse(r.position,n,d,h),u=L(r.position,n.radius,h.position,h.rotation,d.longAxis,d.shortAxis).hit;if(!(!p&&!u)){o.add(i),n.explosion?this.detonateProjectile(e,r,n.explosion,s):this.applyDamageToNoodle(e,a,d,h,n.damage,s);break}}}}handleExpiredProjectiles(e,o,s){const i=e.consumeExpiredProjectiles();for(const n of i){if(o.has(n))continue;const r=e.getProjectile(n),a=e.getTransform(n);if(!r||!a){o.add(n);continue}r.explosion&&this.detonateProjectile(e,a,r.explosion,s),o.add(n)}}detonateProjectile(e,o,s,i){const n={position:{x:o.position.x,y:o.position.y},radius:s.radius,damage:s.damage,impulseStrength:s.impulseStrength,durationSeconds:s.durationSeconds,ageSeconds:t.core.zero};e.addExplosion(n),this.applyExplosion(e,n,i)}applyExplosion(e,o,s){for(const[i,n]of e.getNoodleEntries()){if(s.has(i))continue;const r=e.getTransform(i);if(!r)continue;const a=j(r.position,r.rotation,n.longAxis,n.shortAxis),d=A(o.position,a.start,a.end),h=o.radius+a.radius,p=h*h;if(d>p)continue;const u=Math.sqrt(d),f=t.core.one-b(u/h,t.core.zero,t.core.one),S=o.impulseStrength*f,y=w(r.position,o.position),C=y.x*y.x+y.y*y.y,E=C<=t.math.epsilon*t.math.epsilon?a.axis:g(y,t.core.one/Math.sqrt(C));e.queueImpulse(i,g(E,S)),this.applyDamageToNoodle(e,i,n,r,o.damage,s)}}applyDamageToNoodle(e,o,s,i,n,r){n<=t.core.zero||(s.hp-=n,s.hp<=t.core.zero&&(r.add(o),e.score+=s.scoreValue,this.splitNoodle(e,o,s,i)))}checkProximityFuse(e,o,s,i){if(!o.proximityFuseEnabled)return!1;const r=t.fuse.scale*s.longAxis+o.radius,a=w(e,i.position),d=z(a,a),h=r*r;return d<=h}splitNoodle(e,o,s,i){if(s.longAxis<=t.noodle.splitThreshold)return;const n=e.getRigidBody(o);if(!n)return;const r=s.longAxis*t.noodle.splitScale,a=s.shortAxis*t.noodle.splitScale;let d=t.world.maxNoodles-e.getNoodleCount();if(!(d<=t.core.zero))for(let h=t.core.zero;h<t.noodle.splitCount&&d>t.core.zero;h+=t.core.one){const p=e.rng.range(t.core.zero,t.math.tau),u=e.rng.range(t.noodle.splitImpulseMin,t.noodle.splitImpulseMax),f=g(P(x(t.core.one,t.core.zero),p),u),S={x:n.velocity.x+f.x,y:n.velocity.y+f.y};if(!e.spawnNoodle({x:i.position.x,y:i.position.y},S,r,a,i.rotation,n.angularVelocity))return;d-=t.core.one}}}class H{constructor(e){l(this,"pressed",new Set);l(this,"startRequested",!1);l(this,"fireHeld",!1);l(this,"debugToggleRequested",!1);l(this,"hitboxToggleRequested",!1);l(this,"trailToggleRequested",!1);l(this,"pauseToggleRequested",!1);l(this,"weaponCycle",t.input.turnNone);l(this,"onKeyDown",e=>{e.code===t.input.startKey&&(this.startRequested=!0),e.code===t.input.fireKey&&(this.fireHeld=!0),e.code===t.input.debugToggleKey&&!e.repeat&&(this.debugToggleRequested=!0),e.code===t.input.hitboxToggleKey&&!e.repeat&&(this.hitboxToggleRequested=!0),e.code===t.input.trailToggleKey&&!e.repeat&&(this.trailToggleRequested=!0),e.code===t.input.pauseKey&&!e.repeat&&(this.pauseToggleRequested=!0),e.code===t.input.weaponPrevKey&&!e.repeat&&(this.weaponCycle=t.input.turnLeft),e.code===t.input.weaponNextKey&&!e.repeat&&(this.weaponCycle=t.input.turnRight),this.pressed.add(e.code)});l(this,"onKeyUp",e=>{e.code===t.input.fireKey&&(this.fireHeld=!1),this.pressed.delete(e.code)});l(this,"onBlur",()=>{this.pressed.clear(),this.fireHeld=!1});this.target=e,this.target.addEventListener("keydown",this.onKeyDown),this.target.addEventListener("keyup",this.onKeyUp),this.target.addEventListener("blur",this.onBlur)}update(e,o,s){const i=e.getPlayerShipId(),n=e.getShipControl(i);n&&(n.turn=t.input.turnNone,n.thrusting=!1,o===t.game.states.playing&&!s&&(this.pressed.has(t.input.leftKey)&&(n.turn=t.input.turnLeft),this.pressed.has(t.input.rightKey)&&(n.turn=t.input.turnRight),this.pressed.has(t.input.thrustKey)&&(n.thrusting=!0))),this.debugToggleRequested&&(e.toggleDebug(),this.debugToggleRequested=!1),this.hitboxToggleRequested&&(e.toggleHitboxes(),this.hitboxToggleRequested=!1),this.trailToggleRequested&&(e.toggleProjectileTrails(),this.trailToggleRequested=!1);const r=this.startRequested,a=this.fireHeld&&o===t.game.states.playing&&!s,d=this.weaponCycle,h=this.pauseToggleRequested;return this.startRequested=!1,this.pauseToggleRequested=!1,this.weaponCycle=t.input.turnNone,{startRequested:r,fireRequested:a,weaponCycle:d,pauseToggled:h}}destroy(){this.target.removeEventListener("keydown",this.onKeyDown),this.target.removeEventListener("keyup",this.onKeyUp),this.target.removeEventListener("blur",this.onBlur)}}class O{wrapValue(e,o){const s=t.world.wrapMargin,i=t.core.zero-s,n=o+s;return e<i?n:e>n?i:e}}class K{constructor(){l(this,"wrap",new O)}update(e,o){this.applyImpulses(e),this.updateShips(e,o),this.updateNoodles(e,o),this.updateProjectiles(e,o),this.integrate(e,o),this.updateExplosions(e,o)}updateShips(e,o){for(const[s,i]of e.getShipEntries()){const n=e.getTransform(s),r=e.getRigidBody(s);!n||!r||(n.rotation+=i.turn*t.ship.turnSpeed*o,i.thrusting&&(r.velocity.x+=Math.cos(n.rotation)*t.ship.thrustAccel*o,r.velocity.y+=Math.sin(n.rotation)*t.ship.thrustAccel*o),r.velocity.x*=t.ship.damping,r.velocity.y*=t.ship.damping,this.clampSpeed(r,t.ship.maxSpeed))}}updateNoodles(e,o){for(const[s]of e.getNoodleEntries()){const i=e.getTransform(s),n=e.getRigidBody(s);!i||!n||(i.rotation+=n.angularVelocity*o,n.velocity.x*=t.noodle.damping,n.velocity.y*=t.noodle.damping)}}updateProjectiles(e,o){for(const[s,i]of e.getProjectileEntries()){const n=e.getRigidBody(s),r=e.getLifetime(s);!n||!r||(n.velocity.x+=i.accel.x*o,n.velocity.y+=i.accel.y*o,r.remainingSeconds-=o,r.remainingSeconds<=t.core.zero&&e.markProjectileExpired(s))}}integrate(e,o){for(const[s,i]of e.getRigidBodyEntries()){const n=e.getTransform(s);if(!n)continue;n.position.x+=i.velocity.x*o,n.position.y+=i.velocity.y*o,n.position.x=this.wrap.wrapValue(n.position.x,e.width),n.position.y=this.wrap.wrapValue(n.position.y,e.height);const r=e.getProjectile(s);r&&this.recordTrail(r,n.position)}}clampSpeed(e,o){const s=Math.hypot(e.velocity.x,e.velocity.y);if(s>o&&s>t.core.zero){const i=o/s;e.velocity.x*=i,e.velocity.y*=i}}recordTrail(e,o){const s=t.debug.projectileTrailLength;e.trail.push({x:o.x,y:o.y}),e.trail.length>s&&e.trail.splice(t.core.zero,e.trail.length-s)}applyImpulses(e){const o=e.consumeImpulses();for(const[s,i]of o){const n=e.getRigidBody(s);n&&(n.velocity.x+=i.x,n.velocity.y+=i.y)}}updateExplosions(e,o){const s=[];for(const i of e.explosions)i.ageSeconds+=o,i.ageSeconds<=i.durationSeconds&&s.push(i);e.explosions=s}}class D{constructor(e){this.ctx=e}render(e,o,s){this.drawHud(e,o,s),e.debug.enabled&&this.drawDebugOverlay(e)}drawHud(e,o,s){const i=this.ctx;i.fillStyle=t.canvas.textColor,i.font=`${t.render.hudFontSize}px ${t.render.fontFamily}`,i.textAlign="left",i.textBaseline="top";const n=e.getPlayerShipId(),r=e.getWeaponState(n),a=r?r.weaponId:t.hud.cooldownUnknown,d=this.resolveWeaponName(a),h=this.resolveCooldownText(r),p=[`${t.hud.scoreLabel}: ${e.score}`,`${t.hud.waveLabel}: ${e.wave}`,`${t.hud.weaponLabel}: ${d}`,`${t.hud.cooldownLabel}: ${h}`,`${t.hud.statusLabel}: ${e.getNoodleCount()}`];let u=t.render.lineWidth;for(const f of p)i.fillText(f,t.render.lineWidth,u),u+=t.render.hudLineHeight;o===t.game.states.attract?this.drawCenteredHint(e,t.hud.startHint):o===t.game.states.gameOver?this.drawCenteredHint(e,t.hud.restartHint):s&&this.drawCenteredHint(e,t.hud.pauseHint)}drawDebugOverlay(e){const o=this.ctx,s=t.debug.precision,i=e.debug,n=[`${t.debug.fpsLabel}: ${i.fps.toFixed(s)}`,`${t.debug.frameLabel}: ${i.frameMs.toFixed(s)}${t.debug.msSuffix}`,`${t.debug.accumulatorLabel}: ${i.accumulatorMs.toFixed(s)}${t.debug.msSuffix} ${t.debug.stepLabel}: ${i.fixedStepMs.toFixed(s)}${t.debug.msSuffix} ${t.debug.subStepsLabel}: ${i.subSteps}`,`${t.debug.activeLabel}: ${t.debug.shipLabel} ${e.getShipCount()} ${t.debug.noodleLabel} ${e.getNoodleCount()} ${t.debug.projectileLabel} ${e.getProjectileCount()} ${t.debug.particleLabel} ${e.getParticleCount()}`,`${t.debug.hitboxLabel}: ${i.showHitboxes?t.debug.onLabel:t.debug.offLabel}`];o.fillStyle=t.canvas.textColor,o.font=`${t.debug.overlayFontSize}px ${t.render.fontFamily}`,o.textAlign="left",o.textBaseline="top";const r=t.debug.overlayPadding;let a=t.debug.overlayPadding;for(const d of n)o.fillText(d,r,a),a+=t.debug.overlayLineHeight}drawCenteredHint(e,o){const s=this.ctx;s.font=`${t.render.hintFontSize}px ${t.render.fontFamily}`,s.textAlign="center",s.textBaseline="middle",s.fillStyle=t.canvas.accentColor;const i=e.width/t.world.centerDivisor,n=e.height/t.world.centerDivisor;s.fillText(o,i,n)}resolveWeaponName(e){return e===t.weapon.straightShot.id?t.weapon.straightShot.name:e===t.weapon.parabolic.id?t.weapon.parabolic.name:e===t.weapon.blast.id?t.weapon.blast.name:e===t.weapon.rearCannons.id?t.weapon.rearCannons.name:e}resolveCooldownText(e){return e?e.cooldownRemaining<=t.core.zero?t.hud.cooldownReady:`${e.cooldownRemaining.toFixed(t.hud.cooldownPrecision)}${t.hud.secondsSuffix}`:t.hud.cooldownUnknown}}class k{constructor(e){l(this,"ui");this.ctx=e,this.ui=new D(e)}render(e,o,s){this.clear(e),this.drawNoodles(e),this.drawShips(e),e.debug.enabled&&this.drawFuseRings(e),e.debug.showProjectileTrails&&this.drawProjectileTrails(e),this.drawExplosions(e),this.drawProjectiles(e),e.debug.showHitboxes&&this.drawHitboxes(e),this.ui.render(e,o,s)}clear(e){this.ctx.fillStyle=t.canvas.background,this.ctx.fillRect(t.core.zero,t.core.zero,e.width,e.height)}drawShips(e){const o=this.ctx,s=t.render.shipScale;for(const[i,n]of e.getShipEntries()){const r=e.getTransform(i);if(!r)continue;o.save(),o.translate(r.position.x,r.position.y),o.rotate(r.rotation),o.strokeStyle=t.ship.color,o.lineWidth=t.render.lineWidth;const a=n.radius*t.ship.noseScale*s,d=n.radius*t.ship.wingScale*s,h=n.radius*t.ship.tailScale*s;if(o.beginPath(),o.moveTo(a,t.core.zero),o.lineTo(t.core.negativeOne*h,d),o.lineTo(t.core.negativeOne*h,t.core.negativeOne*d),o.closePath(),o.stroke(),n.thrusting){const p=n.radius*t.ship.flameScale*s;o.beginPath(),o.moveTo(t.core.negativeOne*h,t.core.zero),o.lineTo(t.core.negativeOne*(h+p),t.core.zero),o.stroke()}o.restore()}}drawNoodles(e){const o=this.ctx,s=t.render.noodleScale;o.strokeStyle=t.noodle.color,o.lineWidth=t.render.lineWidth;for(const[i,n]of e.getNoodleEntries()){const r=e.getTransform(i);if(!r)continue;o.save(),o.translate(r.position.x,r.position.y),o.rotate(r.rotation);const a=n.longAxis*s,d=n.shortAxis*s;o.beginPath(),o.ellipse(t.core.zero,t.core.zero,a,d,t.core.zero,t.core.zero,t.math.tau),o.stroke();const h=n.longAxis*t.core.half;o.beginPath(),o.moveTo(t.core.zero,t.core.negativeOne*h),o.lineTo(t.core.zero,h),o.stroke(),o.restore()}}drawFuseRings(e){const o=this.ctx;o.strokeStyle=t.fuse.color,o.lineWidth=t.fuse.lineWidth;for(const[s,i]of e.getNoodleEntries()){const n=e.getTransform(s);if(!n)continue;const r=t.fuse.scale*i.longAxis;o.beginPath(),o.arc(n.position.x,n.position.y,r,t.core.zero,t.math.tau),o.stroke()}}drawProjectiles(e){const o=this.ctx;o.fillStyle=t.projectile.color;for(const[s,i]of e.getProjectileEntries()){const n=e.getTransform(s);n&&(o.beginPath(),o.arc(n.position.x,n.position.y,i.radius,t.core.zero,t.math.tau),o.fill())}}drawExplosions(e){const o=this.ctx;o.strokeStyle=t.explosion.color,o.lineWidth=t.explosion.lineWidth;for(const s of e.explosions){const i=b(s.ageSeconds/s.durationSeconds,t.core.zero,t.core.one),n=s.radius*i;o.beginPath(),o.arc(s.position.x,s.position.y,n,t.core.zero,t.math.tau),o.stroke()}}drawProjectileTrails(e){const o=this.ctx;o.strokeStyle=t.debug.trailColor,o.lineWidth=t.debug.trailLineWidth;for(const[,s]of e.getProjectileEntries()){const i=s.trail;if(!(i.length<t.core.two)){o.beginPath(),o.moveTo(i[t.core.zero].x,i[t.core.zero].y);for(let n=t.core.one;n<i.length;n+=t.core.one)o.lineTo(i[n].x,i[n].y);o.stroke()}}}drawHitboxes(e){const o=this.ctx;o.save(),o.strokeStyle=t.debug.hitboxColor,o.lineWidth=t.debug.hitboxLineWidth;for(const[s,i]of e.getShipEntries()){const n=e.getTransform(s);n&&(o.beginPath(),o.arc(n.position.x,n.position.y,i.radius,t.core.zero,t.math.tau),o.stroke())}for(const[s,i]of e.getNoodleEntries()){const n=e.getTransform(s);if(!n)continue;const r=j(n.position,n.rotation,i.longAxis,i.shortAxis);o.beginPath(),o.moveTo(r.start.x,r.start.y),o.lineTo(r.end.x,r.end.y),o.stroke(),o.beginPath(),o.arc(r.start.x,r.start.y,r.radius,t.core.zero,t.math.tau),o.stroke(),o.beginPath(),o.arc(r.end.x,r.end.y,r.radius,t.core.zero,t.math.tau),o.stroke()}for(const[s,i]of e.getProjectileEntries()){const n=e.getTransform(s);n&&(o.beginPath(),o.arc(n.position.x,n.position.y,i.radius,t.core.zero,t.math.tau),o.stroke())}o.restore()}}class B{constructor(){l(this,"id",t.weapon.blast.id);l(this,"name",t.weapon.blast.name);l(this,"cooldownSeconds",t.weapon.blast.cooldownSeconds)}update(e){}tryFire(e,o){const s=e.getTransform(o),i=e.getRigidBody(o),n=e.getShipControl(o);if(!s||!i||!n)return!1;const r=x(Math.cos(s.rotation),Math.sin(s.rotation)),a=n.radius*t.ship.noseScale*t.weapon.blast.spawnOffsetScale,d=g(r,a),h=m(s.position,d),p=m(g(r,t.weapon.blast.projectileSpeed),i.velocity);return e.spawnProjectile(h,p,t.weapon.blast.lifetimeSeconds,{radius:t.weapon.blast.projectileRadius,damage:t.weapon.blast.projectileDamage,proximityFuseEnabled:!0,explosion:{radius:t.weapon.blast.explosionRadius,damage:t.weapon.blast.explosionDamage,impulseStrength:t.weapon.blast.explosionImpulse,durationSeconds:t.weapon.blast.explosionDurationSeconds}})!==void 0}}class V{constructor(){l(this,"id",t.weapon.parabolic.id);l(this,"name",t.weapon.parabolic.name);l(this,"cooldownSeconds",t.weapon.parabolic.cooldownSeconds)}update(e){}tryFire(e,o){const s=e.getTransform(o),i=e.getRigidBody(o),n=e.getShipControl(o);if(!s||!i||!n)return!1;const r=x(Math.cos(s.rotation),Math.sin(s.rotation)),a=n.radius*t.ship.noseScale*t.weapon.parabolic.spawnOffsetScale,d=g(r,a),h=m(s.position,d),p=m(g(r,t.weapon.parabolic.projectileSpeed),i.velocity);return e.spawnProjectile(h,p,t.projectile.lifetimeSeconds,{accel:{x:t.core.zero,y:t.weapon.parabolic.gravity}})!==void 0}}class U{constructor(){l(this,"id",t.weapon.rearCannons.id);l(this,"name",t.weapon.rearCannons.name);l(this,"cooldownSeconds",t.weapon.rearCannons.cooldownSeconds)}update(e){}tryFire(e,o){const s=e.getTransform(o),i=e.getRigidBody(o);if(!s||!i)return!1;const n=t.weapon.rearCannons.hardpoints,r=n.length;if(r<=t.core.zero||e.getProjectileCount()+r>t.world.maxProjectiles)return!1;const a=x(Math.cos(s.rotation),Math.sin(s.rotation)),d=g(a,t.core.negativeOne);for(const h of n){const p=x(h.x,h.y),u=P(p,s.rotation),f=m(s.position,u),S=m(g(d,t.weapon.rearCannons.projectileSpeed),i.velocity);if(!e.spawnProjectile(f,S,t.weapon.rearCannons.lifetimeSeconds))return!1}return!0}}class Y{constructor(){l(this,"id",t.weapon.straightShot.id);l(this,"name",t.weapon.straightShot.name);l(this,"cooldownSeconds",t.weapon.straightShot.cooldownSeconds)}update(e){}tryFire(e,o){const s=e.getTransform(o),i=e.getRigidBody(o),n=e.getShipControl(o);if(!s||!i||!n)return!1;const r=x(Math.cos(s.rotation),Math.sin(s.rotation)),a=n.radius*t.ship.noseScale*t.weapon.straightShot.spawnOffsetScale,d=g(r,a),h=m(s.position,d),p=m(g(r,t.weapon.straightShot.projectileSpeed),i.velocity);return e.spawnProjectile(h,p,t.projectile.lifetimeSeconds)!==void 0}}class X{constructor(){l(this,"weapons",[new Y,new V,new B,new U]);l(this,"weaponMap",new Map(this.weapons.map(e=>[e.id,e])))}update(e,o){for(const s of this.weapons)s.update(o);for(const[,s]of e.getWeaponStateEntries())s.cooldownRemaining>t.core.zero&&(s.cooldownRemaining=Math.max(t.core.zero,s.cooldownRemaining-o))}tryFire(e,o){const s=e.getWeaponState(o);if(!s)return;const i=this.weaponMap.get(s.weaponId);i&&(s.cooldownRemaining>t.core.zero||i.tryFire(e,o)&&(s.cooldownRemaining=i.cooldownSeconds))}cycleWeapon(e,o,s){if(this.weapons.length===t.core.zero)return;const i=e.getWeaponState(o);if(!i)return;const n=this.weapons.findIndex(d=>d.id===i.weaponId),r=n===t.core.negativeOne?t.core.zero:n,a=this.wrapIndex(r+s,this.weapons.length);i.weaponId=this.weapons[a].id,i.cooldownRemaining=t.core.zero}getWeaponName(e){const o=this.weaponMap.get(e);return o?o.name:e}getWeaponCooldown(e){const o=this.weaponMap.get(e);return o?o.cooldownSeconds:t.core.zero}wrapIndex(e,o){if(o<=t.core.zero)return t.core.zero;const s=e%o;return s<t.core.zero?s+o:s}}class G{constructor(e,o){l(this,"state",t.game.states.attract);l(this,"world");l(this,"input");l(this,"physics",new K);l(this,"collision",new $);l(this,"renderer");l(this,"weapons",new X);l(this,"lastTimeMs",t.core.zero);l(this,"accumulatorMs",t.core.zero);l(this,"paused",!1);l(this,"step",e=>{this.lastTimeMs===t.core.zero&&(this.lastTimeMs=e);let o=e-this.lastTimeMs;this.lastTimeMs=e,o>t.timing.maxFrameMs&&(o=t.timing.maxFrameMs),this.accumulatorMs+=o;const s=t.timing.msPerSecond/t.timing.fixedFps,i=s/t.timing.msPerSecond;let n=t.core.zero;for(;this.accumulatorMs>=s&&n<t.timing.maxSubSteps;)this.update(i),this.accumulatorMs-=s,n+=t.core.one;this.updateDebug(o,s,n),this.render(),requestAnimationFrame(this.step)});const s=e.clientWidth||t.core.zero,i=e.clientHeight||t.core.zero;this.world=new M(s,i),this.input=new H(window),this.renderer=new k(o)}start(){requestAnimationFrame(this.step)}resize(e,o){this.world.setSize(e,o)}update(e){const o=this.input.update(this.world,this.state,this.paused);if(this.state===t.game.states.attract&&o.startRequested&&(this.state=t.game.states.playing,this.paused=!1,this.beginWaveIfNeeded()),this.state===t.game.states.gameOver&&o.startRequested){this.restart();return}if(this.state===t.game.states.playing&&(o.pauseToggled&&(this.paused=!this.paused),!this.paused)){if(o.weaponCycle!==t.input.turnNone&&this.weapons.cycleWeapon(this.world,this.world.getPlayerShipId(),o.weaponCycle),this.weapons.update(this.world,e),o.fireRequested&&this.weapons.tryFire(this.world,this.world.getPlayerShipId()),this.physics.update(this.world,e),this.collision.update(this.world),this.world.collisions.length>t.core.zero){this.state=t.game.states.gameOver;return}this.world.getNoodleCount()===t.core.zero&&this.advanceWave()}}render(){this.renderer.render(this.world,this.state,this.paused)}restart(){const e=this.world.width,o=this.world.height;this.world=new M(e,o),this.state=t.game.states.playing,this.paused=!1,this.beginWaveIfNeeded()}beginWaveIfNeeded(){this.world.getNoodleCount()>t.core.zero||this.spawnWave()}advanceWave(){this.world.wave+=t.core.one,this.spawnWave()}spawnWave(){const e=this.world.getPlayerShipId(),o=this.world.getShipControl(e),s=t.wave.safeRadius+(o?o.radius:t.core.zero),i=Math.max(t.core.zero,this.world.wave-t.core.one),n=t.wave.baseNoodles+i*t.wave.increment,r=Math.min(n,t.world.maxNoodles);this.world.spawnWave(r,s)}updateDebug(e,o,s){const i=this.world.debug;if(i.frameMs=e,i.accumulatorMs=this.accumulatorMs,i.fixedStepMs=o,i.subSteps=s,e>t.core.zero){const n=t.timing.msPerSecond/e,r=t.debug.fpsSmoothing;i.fps=i.fps===t.core.zero?n:i.fps*r+n*(t.core.one-r)}}}const v=document.getElementById(t.dom.canvasId);if(!(v instanceof HTMLCanvasElement))throw new Error("Canvas element missing");const T=v.getContext("2d");if(!T)throw new Error("Canvas context unavailable");const N=new G(v,T),Q=q(v,T,(c,e)=>{N.resize(c,e)});window.addEventListener("resize",()=>{Q()});N.start();
